<!DOCTYPE html>
<html>

<head>

<title>
korokoro
</title>

<style>
body
{
	margin: 0 !important;
	padding: 10px !important;
}

#outer
{
	margin: 0 !important;
	height: 100%;
	width: 100%;
	background-color: white;
}

#container
{
	cursor: none;
	margin: 0 auto;
	height: 640px;
	width: 1024px;
	background-color: black;
}

#note
{
	margin: 0 auto;
	width: 1024px;
}
</style>

<script src="../libs/three.min.js"></script>
<script src="racetrack.js"></script>
<script src="marble.js"></script>
<script src="randomcube.js"></script>

<script type="text/javascript">

var c_buttonA = 0;
var c_buttonB = 1;
var c_buttonX = 2;
var c_buttonY = 3;
var c_buttonBack = 8;
var c_buttonStart = 9;
var c_buttonUp = 12;
var c_buttonDown = 13;
var c_buttonLeft = 14;
var c_buttonRight = 15;

var _rAF = window.mozRequestAnimationFrame ||
	window.requestAnimationFrame ||
	window.webkitRequestAnimationFrame;

var _scene;
var _renderer;
var _camera;
var _cameraPos = { x: 0, y: 1.3333, z: 3.3333 };

var _gamepad1;
var _gamepad2;

var _marble1; // = { textureName: 'images/texture1.png', mesh: null };
var _marble2; // = { textureName: 'images/texture2.png', mesh: null };

var _raceTrack;
var _run = false;
var _time = 0;

function onLoadFunc() 
{
	// Grab our container div 
	var container = document.getElementById("container"); 

	// Create the Three.js renderer, add it to our div 
	_renderer = new THREE.WebGLRenderer();
	_renderer.setSize(container.offsetWidth, container.offsetHeight);
	container.appendChild(_renderer.domElement); 

	// Create a new Three.js scene 
	_scene = new THREE.Scene(); 

	// Put in a camera 
	_camera = new THREE.PerspectiveCamera
		(45, container.offsetWidth / container.offsetHeight, 1, 4000 ); 
	_camera.position.set(_cameraPos.x, _cameraPos.y, _cameraPos.z );

	// Create a directional light to show off the object 
	var light = new THREE.DirectionalLight(0xffffff, 1.5); 
	light.position.set(0, 0, 1);
	_scene.add(light); 

	// Create a shaded, texture-mapped cube, objects and add them to the scene 
	var texLoader = new THREE.TextureLoader();

	_marble1 = new Marble(_scene, 'images/texture1.png');
	texLoader.load(_marble1.textureName, function(texture) {
		_marble1.Init(texture);
		_marble1.mesh.position.x = 0.5;
	});

	_marble2 = new Marble(_scene, 'images/texture2.png');
	texLoader.load(_marble2.textureName, function(texture) {
		_marble2.Init(texture);
		_marble2.mesh.position.x = -0.5;
	});

	_raceTrack = new RaceTrack(_scene);
	_raceTrack.Init();

	var cube = new RandomCube(_scene);
	cube.Init();

	// Don't need to render here. (Textures are not loaded at this point anyway.)
	_renderer.render(_scene, _camera);
}

function onKeyUpFunc(e)
{
	var key = e.keyCode ? e.keyCode : e.which;
	if (key == 32) // Space key
		_run = true;
	else if (key == 38) // Up
		_cameraPos.z -= 0.01;
	else if (key == 40) // Down
		_cameraPos.z += 0.01;
	else if (key == 37) // Left
		_cameraPos.x -= 0.01;
	else if (key == 39) // Right
		_cameraPos.x += 0.01;
	updateStatus();
}

function scanGamepads()
{
	_gamepad1 = null;
	_gamepad2 = null;

	var gamepads = navigator.getGamepads();
	if (gamepads)
	{
		if (gamepads.length > 0)
			_gamepad1 = gamepads[0];

		if (gamepads.length > 1)
			_gamepad2 = gamepads[1];
	}
}

function isButtonPressed(button)
{
	var pressed = button == 1.0;
	if (typeof(button) == "object")
	{
		pressed = button.pressed;
		button = button.value;
	}
	return pressed;
}

function updatePlayer(gamepad, marble)
{
	if (!gamepad)
		return;

	var buttons = gamepad.buttons;
	for (var i = 0; i < buttons.length; i++)
	{
		if (isButtonPressed(buttons[i]))
		{
			marble.mesh.rotation.x -= 0.05;
			if (i == c_buttonRight)
				marble.mesh.position.x -= 0.01;
			else if (i == c_buttonLeft)
				marble.mesh.position.x += 0.01;
			else if (i == c_buttonA)
				marble.mesh.position.z -= 0.01;
			else if (i == c_buttonB)
				marble.mesh.position.z += 0.01;
			else if (i == c_buttonUp)
				_cameraPos.z -= 0.01;
			else if (i == c_buttonDown)
				_cameraPos.z += 0.01;
			else if (i == c_buttonX)
				_cameraPos.x -= 0.01;
			else if (i == c_buttonY)
				_cameraPos.x += 0.01;
		}
	}
}

function updateStatus()
{
	scanGamepads();

	updatePlayer(_gamepad1, _marble1);
	updatePlayer(_gamepad2, _marble2);

	if (_run)
	{
		_time += 0.01;
		var camPosition = _raceTrack.GetCameraPos(_time);
		var camFocus = _raceTrack.GetFocusPos(_time);
		if (camFocus == null || camPosition == null)
		{
			_run = false;
			_time = 0;
		}
		else
		{
			_camera.position.set(camPosition.x, camPosition.y, camPosition.z);
			_camera.lookAt(camFocus);
		}
	}
	else
	{
		//_camera.position.set(_cameraPos.x, _cameraPos.y, _cameraPos.z);
		//_camera.lookAt(_marble1.mesh.position)
	}

	_renderer.render(_scene, _camera);

	_rAF(updateStatus)
}

function addGamepad(gamepad)
{
	console.log("index: " + gamepad.index);
	console.log("id: " + gamepad.id);
	console.log("buttons.length: " + gamepad.buttons.length);
	console.log("axes.length: " + gamepad.axes.length);

	updateStatus();
}

function removeGamepad(gamepad)
{
	console.log("index: " + gamepad.index);
	console.log("id: " + gamepad.id);
}

function connectHandler(e)
{
	addGamepad(e.gamepad);
}

function disconnectHandler(e)
{
	removeGamepad(e.gamepad);
}

function run()
{
	window.addEventListener("load", function() {
		onLoadFunc();
	});

	window.onkeyup = function(e) {
		onKeyUpFunc(e);
	}

	var haveEvents = 'GamepadEvent' in window;
	if (haveEvents)
	{
		window.addEventListener("gamepadconnected", connectHandler);
		window.addEventListener("gamepaddisconnected", disconnectHandler);
	}
	else
	{
		setInterval(scanGamepads, 500);
	}
}

// main function
(function() {
	console.log("korkokoro starts...");
	run();
})();

</script>
</head>

<body>
<div id="outer">
	<div id="container">
	</div>
	<div id="note">
		When you reload this page, gamepads may not be detected.
		Switch to another chrome tab and come back. Gamepads probably will start working again.
	</div>
</div>
</body>

</html>
